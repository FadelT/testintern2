# -*- coding: utf-8 -*-
"""Ktest2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fCIl1u5_LaptMJ8aZV2S5If5L2pXUPoG
"""

import numpy as np

def reconn_tirage(data):
    #L=[]
    # Paramètres ajustables

    # en secondes : temps à partir duquel on considèrera qu'il y a fin du tirage si aucun autre tirage n'a été rencontré
    limite_tirage=120

    # en degrés : augmentation d'amplitude à partir de laquelle on considère qu'il y a tirage
    limite_amplitude=2

    # en degrés : Pas instantané mini à partir duquel on considère qu'il y a tirage
    limite_Pmax=1

    # en secondes : temps minimum de baisse de température pour considérer comme un tirage
    seuil_minimum=4

    # en secondes : temps avant début tirage
    avant_tirage=0

    # Pour une plus grande rapidité du programme -> initialiser à vide les matrices avant la boucle for

    # Matrice contenant les indexs du maximum de chaque tirage
    #indexsmax=np.zeros(len(data))
    indexsmax=[0]*len(data)
    # Matrice contenant les indexs du début de chaque tirage
    #indexsdebut=np.zeros(len(data))
    indexsdebut = [0] * len(data)
    # Matrice contenant les indexs de la fin de chaque tirage
    #indexsfin=np.zeros(len(data))
    indexsfin = [0] * len(data)
    #pentes = np.zeros(len(data))
    pentes = [0] * len(data)

    # Compteur de montée
    cptmonte=0

    # pente maxi détectée, pour chaque montée, entre 2 points consécutifs
    Pmax = 0

 # Boucle de parcours des données
    for i in range(2,len(data),1):
    #Si la donnée précédente est inférieure à la suivante : il y a montée
        if data[i] > data[i-1]:
        # Augmenter le compteur indiquant qu'il y a montée
            cptmonte=cptmonte+1
            #print(cptmonte)
        # Mise à jour de Pmax
            if data[i] - data[i-1] > Pmax:
                Pmax = data[i] - data[i-1]
        # Si la donnée précédente est supérieure à la suivante et que le
        # compteur de montée est différent de 0 : il y a redescente après une montée
        elif data[i] <= data[i-1] and cptmonte!=0:
        # Si la montée est supérieure ou égale à la limite indiquée en début de programme
            if data[i-1]-data[i-1-cptmonte] >= limite_amplitude:
            # Récupérer le nombre de cases de indexsdebut remplies
                #longueur=len(indexsdebut!=0)
                longueur=np.count_nonzero(indexsdebut)
            # S'il y a au moins un indexsdebut renseigné
                if longueur!=0:
                # Indiquer l'index de fin : on considère le début du suivant comme la fin du précédent
                    #indexsfin[i-cptmonte]=i-cptmonte-1
                    indexsfin[i - cptmonte] = i - cptmonte-1 #- 1

            # Indiquer l'index de début du tirage
                #indexsdebut[i-cptmonte]=i-cptmonte-1
                indexsdebut[i - cptmonte] = i - cptmonte-1 #- 1
                pentes[i-cptmonte]=Pmax
            # Indiquer l'index du maximum du tirage
                indexsmax[i]=i-1
                #print(i,indexsmax[i])


            # On remet le compteur à 0
            cptmonte=0
            Pmax = 0

    #trace = table(indexsdebut, indexsfin, indexsmax, pentes);

    #on renseigne indexfin du dernier tirage
    indexsfin[len(data)-1] = len(data)
    #print(indexsfin)

    # Supprimer les cases vides des matrices
    #indexsdebut[indexsdebut==0]=[]
    indexsdebut=list(filter(lambda a: a != 0, indexsdebut))
    #indexsdebut=indexsdebut[indexsdebut != 0]
    #indexsfin[indexsfin==0]=[
    #indexsfin=indexsfin[indexsfin != 0]
    indexsfin=list(filter(lambda a: a != 0, indexsfin))
    #indexsmax[indexsmax==0]=[]
    #indexsmax=indexsmax[indexsmax != 0]
    indexsmax=list(filter(lambda a: a != 0, indexsmax))
    #pentes[pentes==0]=[]
    #pentes=pentes[pentes != 0]
    pente=list(filter(lambda a: a != 0, pentes))
    #print(pentes)

    #trace = table(indexsdebut, indexsfin, indexsmax, pentes): A modifier

    # Parcours des indexs de fin de tirage
    for i in range(len(indexsfin)):
        # Si le temps entre le début et la fin du tirage est supérieur au temps indiqué en début de programme
        if indexsfin[i]-indexsdebut[i]>limite_tirage:#changement d'indice
            # Mettre à jour l'index de fin
            indexsfin[i]=indexsdebut[i]+limite_tirage

    for i in range(len(indexsfin)):
        if indexsfin[i]-indexsmax[i]<seuil_minimum:
            # Supprimer les indexs de ce tirage des trois matrices
            indexsdebut[i]=0
            indexsfin[i]=0
            indexsmax[i]=0
        elif pente[i]<limite_Pmax:#supprimer les points dont la pentes est faible: On les affecte d'abord à zéro
             indexsdebut[i]=0
             indexsfin[i]=0
             indexsmax[i]=0

    pente = list(filter(lambda a: a >=limite_Pmax , pente))
    # Supprimer les cases vides des matrices
    #indexsdebut=indexsdebut[indexsdebut!=0]

    indexsdebut = list(filter(lambda a: a != 0, indexsdebut))
    #indexsfin=indexsfin[indexsfin!=0]
    indexsfin = list(filter(lambda a: a != 0, indexsfin))
    indexsdebut = [a-avant_tirage for a in indexsdebut]
    #print(indexsdebut)
    return indexsdebut, indexsfin

#function [theta] = analyse_tirage_chaud(data)

    #FONCTION DE DETERMINATION DES VARIABLES POUR MINIMISATION DE LA FONCTION COUT
    fig=go.Figure()
    data=pd.Series(list(data.values))#modifier afin d'avoir l'index exact du maximum

    #print("data_init:{}".format(data))
    # Températures
    Temp0=data.iloc[0]
    # Température initiale (en degrés)
    Temp_finale = data.iloc[-1]
    Tmax=max(data)
    Tmin=min(data)
    # Température maximale atteinte (en degrés)

    Epsilon = 0.1 # seuil de bruit, en degrés

    if (Tmax-Temp_finale) > 2 :#% en dessous, on considère qu'on ne peut pas enlever de points à la fin

        #%% On nettoie les données en supprimant les derniers points tant qu'ils remontent

        index = len(data)-1
        nb_points_a_supprimer = 0

        while data.iloc[index] > (data.iloc[index-1]-Epsilon) and index>2 :
            index = index-1
            nb_points_a_supprimer = nb_points_a_supprimer+1


        if index>2:
            data = data.iloc[0:len(data)-1-nb_points_a_supprimer]




    # Trouver l'index du maximum du tirage
    indexmax=data.idxmax() # a revoir

    #% Amplitudes
    Amp1=Tmax-Temp0
    #Amplitude d'augmentation de la température (en degrés)
    Amp2=Tmax-min(Tmin,20)
    #% Amplitude de baisse de la température (en degrés)
    #% (à affiner en remplaçant 20 par la T° ambiante)

    #% Moment du début de montée (en secondes)
    #print(type(data.iloc[1:indexmax]))
    #gradients = data.iloc[1:indexmax].tolist() - data.iloc[0:indexmax-1].tolist()
    #print("data:{}".format(data))
    gradients = data.copy().iloc[0:indexmax+1].diff()[1:]#il faut réindexer le gradient
    #ipdb.set_trace(gradients=None)
    if len(gradients)==0:
      print(data)
      print(gradients)
    #print("gradient: {}".format(gradients))
    #print(gradients)
    #t0= max(gradients)
    t0=gradients.idxmax()-1
    #print( "t0: {}".format(t0))
    #print("data[t0]:{}".format(data.iloc[t0]))
    #print(t0)
    # Moment du début de descente (en secondes)
    # on remonte la courbe à l'envers et on s'arrête quand ça ne remonte plus
    # 1 point toutes les 100 secondes à cause des perturbations

    t1 = len(data)
    pas = 2
    #print(t1)
    #print(np.mean(data.iloc[t1-pas:t1]))
    #print(data)
    #% on part de cet endroit et on remonte la courbe à l'envers
    #while mean(data(t1-pas:t1)) < mean(data(t1-2*pas:t1-pas)) && t1> max(3*pas,indexmax+pas)
    #t1 = t1-pas;
    while np.mean(data.iloc[t1-1-pas:t1]) < np.mean(data.iloc[t1-1-2*pas:t1-pas]) and t1> max(3*pas,indexmax+pas):
          t1 = t1-pas
    #print(t1)

    #% Dissymétries
    alpha=1 # % Dissymétrie de montée
    beta=0.02#     % Dissymétrie de descente
    #%pente = 0# % pente juste avant le step de montée (rafinement)


   # % Inverser la matrice de données
    #data=np.transpose(data)#A revoir
   #% Matrice de temps
    #t=1:len(data)
    t=np.arange(len(data))

    x0=(Temp0, Amp1, t0, alpha ,Amp2 ,t1, beta)


    modele=modele_total(Temp0,Amp1,alpha,t,t0,Amp2,beta,t1)
    #print(t)
    #print(t0)
    #print(modele)
    #plot(t,data,'r')

    #plt.plot(t,data,'r')
    #fig = px.line( x=t, y=data)
    #fig.add_trace(go.Scatter(x=t, y=data, name="données",line_shape='linear',fillcolor='red'))

    #hold on
    #plot(t,modele,'b')
    #print(modele)
    #plt.plot(t,modele,'b')
    #fig = px.line( x=t, y=modele)
    #fig.add_trace(go.Scatter(x=t, y=modele, name="modele_initial",line_shape='linear',fillcolor='blue'))
    #hold on

    t0_ini = t0
    t1_ini = t1


    #% Création de la fonction coût à optimiser
    cout=lambda x: optimise_total(x,data,t,modele_total,Tmax-Temp0)


    #cout=optimise_total(x,data,t,modele_total,Tmax-Temp0)
    #% Options d'optimisation :pas de contraintes, algorithme de quasi-newton, ne pas afficher les itérations
    #options1 = optimoptions('fminunc','Algorithm','quasi-newton','display','none')
    #options1.MaxFunctionEvaluations=10000
    #options2 = optimset('fminsearch')
    #options2 = optimset('display','none')
    #options2.MaxFunEvals=10000

    gain_cout = 999
    best_cout = 999

    essai_theta = x0
    while (gain_cout>0.01):
        best_cout0 = best_cout
        #% On boucle entre les 2 algos jusqu'à ne plus progresser
        #[essai_theta, best_cout] = fminunc(cout,essai_theta,options1)
        #[essai_theta, best_cout]  =minimize(cout,essai_theta,method='SLSQP')#A revoir
        res=minimize(cout,essai_theta,method='Nelder-Mead')#,bounds=((Temp0,None), (2,Tmax), (1,None), (0.1,5),(0,None),(None,None), (0,None)))#A revoir
        #res=optimize.least_squares(cout,essai_theta)#bounds=((Temp0,None), (2,Tmax), (1,None), (0.1,5),(0,None),(None,None), (0,None)))

        essai_theta=res.x
        best_cout=res.fun
        essai_theta[0] = max(Temp0,essai_theta[0]) #% Temp0 >= 1er point de la courbe
        essai_theta[1] = max(2,essai_theta[1]) #% Amp1 >= 2
        essai_theta[1] = min(Tmax-Temp0,essai_theta[1]) #%Amp1 <= Tmax-Temp0
        essai_theta[2] = max(0,essai_theta[2]) #% t0 >= 1
        essai_theta[3]=max(0.1,essai_theta[3]) #% alpha >= 0.1
        essai_theta[3]=min(5,essai_theta[3]) #% alpha <= 5
        essai_theta[4]=max(0,essai_theta[4]) #% Amp2 >= 0
        essai_theta[5] = max(essai_theta[2]+1,essai_theta[5]) #% t1 >= t0 + 1
        essai_theta[6]=max(0,essai_theta[6]) #% beta >= 0

        #[essai_theta, best_cout] = fminsearch(cout,essai_theta,options2)
        #xopt = optimize.fmin(func=cout, x0=essai_theta)
        #[essai_theta, best_cout]=optimize.fmin(func=cout, x0=essai_theta)
        res2=optimize.fmin(func=cout, x0=essai_theta,maxiter=10000)#equivalent de fminsearch en scipy
        #print(res2)
        best_cout=optimise_total(res2,data,t,modele_total,Tmax-Temp0)###"
        #best_cout=modele_totale(essai_theta[0],essai_theta[1],essai_theta[2],essai_theta[3],essai_theta[4],essai_theta[5],essai_theta[6])
        essai_theta[0] = max(Temp0,essai_theta[0]) #"% Temp0 >= 1er point de la courbe
        essai_theta[1] = max(2,essai_theta[1]) #% Amp1 >= 2
        essai_theta[1] = min(Tmax-Temp0,essai_theta[1]) #%Amp1 <= Tmax-Temp0
        essai_theta[2] = max(0,essai_theta[2]) #% t0 >= 1 t0>=0
        essai_theta[3]= max(0.1,essai_theta[3]) #% alpha >= 0.1
        essai_theta[3]= min(5,essai_theta[3]) #% alpha <= 5
        essai_theta[4]= max(0,essai_theta[4]) #% Amp2 >= 0
        essai_theta[5] = max(essai_theta[2]+1,essai_theta[5])# % t1 >= t0 + 1
        essai_theta[6]=max(0,essai_theta[6]) #% beta >= 0

        gain_cout = best_cout0 - best_cout


    theta = essai_theta

    if (t1_ini-indexmax) > 5 and best_cout>0.05:
        #% On fait 10 essais, en initialisant t1 uniformément, entre indexmax et t1_ini
        nb_essais = 10
        for essai in range(nb_essais):
            x0=list(x0)
            x0[6] = x0[6] - (t1_ini-indexmax)/nb_essais
            if x0[6] < essai_theta[6]: # % sinon, pas la peine, il est déjà allé plus bas
                essai_theta = x0
                gain_cout = 999
                cout_atteint = 999
                while (gain_cout>0.01):
                    best_cout0 = cout_atteint
                    #% On boucle entre les 2 algos jusqu'à ne plus progresser
                    #[essai_theta, cout_atteint] = fminunc(cout,essai_theta,options1)
                    res = minimize(cout, essai_theta, method='Nelder-Mead')#,bounds=((Temp0,None), (2,Tmax), (1,None), (0.1,5),(0,None),(None,None), (0,None)))  # A revoir
                    #res=optimize.least_squares(cout,essai_theta)#,bounds=((Temp0,None), (2,Tmax), (1,None), (0.1,5),(0,None),(None,None), (0,None)))
                    essai_theta = res.x
                    best_cout = res.fun
                    essai_theta[0] = max(Temp0,essai_theta[0])# % Temp0 >= 1er point de la courbe
                    essai_theta[1] = max(2,essai_theta[1]) #% Amp1 >= 2
                    essai_theta[1] = min(Tmax-Temp0,essai_theta[1])#; %Amp1 <= Tmax-Temp0
                    essai_theta[2] = max(0,essai_theta[2])#; % t0 >= 1
                    essai_theta[3]=max(0.1,essai_theta[3])#; % alpha >= 0.1
                    essai_theta[3]=min(5,essai_theta[3])#; % alpha <= 5
                    essai_theta[4]=max(0,essai_theta[4])#; % Amp2 >= 0
                    essai_theta[5] = max(essai_theta[2]+1,essai_theta[5])#; % t1 >= t0 + 1
                    essai_theta[6]=max(0,essai_theta[6])#; % beta >= 0


                    res2=optimize.fmin(func=cout, x0=essai_theta,maxiter=10000)#equivalent de fminsearch en scipy
                    #print(res2)
                    best_cout=optimise_total(res2,data,t,modele_total,Tmax-Temp0)###"
                    #best_cout=modele_totale(essai_theta[0],essai_theta[1],essai_theta[2],essai_theta[3],essai_theta[4],essai_theta[5],essai_theta[6])
                    essai_theta[0] = max(Temp0,essai_theta[0]) #"% Temp0 >= 1er point de la courbe
                    essai_theta[1] = max(2,essai_theta[1]) #% Amp1 >= 2
                    essai_theta[1] = min(Tmax-Temp0,essai_theta[1]) #%Amp1 <= Tmax-Temp0
                    essai_theta[2] = max(0,essai_theta[2]) #% t0 >= 1
                    essai_theta[3]=max(0.1,essai_theta[3]) #% alpha >= 0.1
                    essai_theta[3]=min(5,essai_theta[3]) #% alpha <= 5
                    essai_theta[4]=max(0,essai_theta[4]) #% Amp2 >= 0
                    essai_theta[5] = max(essai_theta[2]+1,essai_theta[5])# % t1 >= t0 + 1
                    essai_theta[6]=max(0,essai_theta[6]) #% beta >= 0

                    gain_cout = best_cout0 - cout_atteint#;


                if cout_atteint < best_cout:
                    best_cout = cout_atteint
                    theta = essai_theta
            x0=tuple(x0)#remettre au format initial

    #% Récupérer les variables retournées
    Temp0=theta[0]
    Amp1=theta[1]
    t0=theta[2]
    alpha=theta[3]
    Amp2=theta[4]
    t1=theta[5]
    beta=theta[6]
    #%pente=theta(8)

    #% Fonction totale avec les valeurs de variables après optimisation
    t=np.arange(len(data))

    modele=modele_total(Temp0,Amp1,alpha,t,t0,Amp2,beta,t1)

    #plot(t,modele,'g')
    #plt.plot(t,modele,'g')
    #fig=px.line(x=t,y=modele)
    #fig.add_trace(go.Scatter(x=t, y=modele, name="modele_final",line_shape='linear',fillcolor='green'))
    #fig.show()
    #plt.show()
    theta=theta[0:7]

    #% Calculer l'erreur entre le modèle et le tirage de base
    erreur=modele-data

    #% Calculer le coût
    cout=np.mean(erreur**2)

# % Ajouter le coût à la matrice theta à retourner
# %%
    theta=theta.tolist()
    theta.append(cout)
    return theta

import tensorflow as tf
from tqdm import tqdm
from reconnaissance_tirage import reconn_tirage
from analyse_tir import analyse_tir
import pandas as pd
from multiprocessing import Pool
import cupy as cp
from tensorflow.python.client import device_lib
#print(tf.__version__)

#print(device_lib.list_local_devices())
#print(tf.test.is_built_with_cuda())

Donnee_Minutes_df=pd.read_csv("/users/promo2021/nkassinga/testintern/Kirchhoffer_Donnees_minute.csv",sep=";")
Donnee_Minutes_df.head()

def detect_tirage(Donnee_Minutes_df):
    datahot_lisse=Donnee_Minutes_df.iloc[:,1].rolling(window=2).mean()
    indexsdebut, indexsfin=reconn_tirage(datahot_lisse)
    #print("indexdebut:{}".format(indexsdebut))
    #print("indexsfin:{}".format(indexsfin))
    L=[]
    for i in tqdm(range(len(indexsdebut))):
      data=Donnee_Minutes_df.iloc[indexsdebut[i]:indexsfin[i]+1,1]
      #L.append(analyse_tir(data))
      L.append(data)
    L_gpu=cp.asarray(L)
    if __name__ == '__main__':
        with Pool(12) as P:
            L_gpu = P.map(analyse_tir,L_gpu)
    #L=list(map(analyse_tir,L))


    Donnees_Tirages_df=pd.DataFrame(L,columns=["temperature_0","amplitude_1","temp0","alpha","amplitude_2","temp1","beta","cout"])

    return Donnees_Tirages_df

Donnee=Donnee_Minutes_df.iloc[:3000,:]
df=detect_tirage(Donnee)
df.to_csv('/users/promo2021/nkassinga/testintern/don_tirV3.csv"')
print(type(df))